<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | Jørgen's Blog]]></title>
  <link href="http://jorgen.tjer.no/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://jorgen.tjer.no/"/>
  <updated>2014-05-26T21:48:01-07:00</updated>
  <id>http://jorgen.tjer.no/</id>
  <author>
    <name><![CDATA[Jørgen Tjernø]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Self-contained game distribution on Linux]]></title>
    <link href="http://jorgen.tjer.no/post/2014/05/26/self-contained-game-distribution-on-linux/"/>
    <updated>2014-05-26T21:10:28-07:00</updated>
    <id>http://jorgen.tjer.no/post/2014/05/26/self-contained-game-distribution-on-linux</id>
    <content type="html"><![CDATA[<p>Distributing a game on Linux can be a little intimidating, and there are
definitely pitfalls. The main problem is making sure your game runs on
all of your users' machines, and outside of hardware and drivers, the
root of the problem is usually one of two things:</p>

<ol>
<li>You make an assumption about what libraries are present on the system.</li>
<li>You make an assumption about what version of a library is present on the system.</li>
</ol>


<p>This is very easy to accidentally do, as adding <code>-lSDL2</code> to the linker&rsquo;s
command line might work perfectly fine on your machine, but you forgot
that you installed SDL2 by hand 4 months ago. Another cause could be
that while <strong>your</strong> Linux distribution came with SDL2 preinstalled,
another distribution (that your users use) might not. Finally, maybe
your distribution came with v2 of some library, but your users only have
v1.</p>

<p>The best way to avoid this is to make your game distribution &ldquo;hermetic,&rdquo;
meaning that it contains all of its own dependencies. There are two main
ways to achieve this:</p>

<ol>
<li>Statically linking with all of your dependencies.</li>
<li>Dynamically linking with all of your dependencies, and pointing the
system&rsquo;s runtime loader at a copy of the libraries you bundle with
your game.</li>
</ol>


<p>Statically linking comes with its own set of problems, so this post
talks about solving the problem with dynamic linking.</p>

<h2>Introducing the steam-runtime</h2>

<p>It turns out that Valve has already solved this problem in Steam with
<a href="https://github.com/ValveSoftware/steam-runtime">something called the steam-runtime</a>. Contrary to what
its name indicates, it has <strong>no direct dependency on Steam nor does it
even assume that it is installed</strong>. It is merely a controlled set of
open source libraries (with some patches) and associated tools to use
those libraries &ndash; to make your game build hermetic.</p>

<!-- more -->


<p>If your game is running under Steam, you don&rsquo;t need to do much. Build
your game with the steam-runtime SDK, make sure all of your dependencies
exist inside of the runtime, and ship the game binaries to Steam. On the
receiving end, Steam will make sure that your users have the latest
version of the steam-runtime, and execute your game inside of it.</p>

<p>If you, like many others, also distribute your game outside of Steam,
you&rsquo;ll need to find another solution. The obvious solution is to build
on their work &ndash; it&rsquo;s an open source project that solves the problem
perfectly!</p>

<h2>Workings of the steam-runtime</h2>

<p>When I say that your game is executed &ldquo;inside&rdquo; of the runtime when
launched through Steam, I specifically mean that:</p>

<ul>
<li>The steam-runtime being present in some location Steam knows about</li>
<li>Steam sets the <code>LD_LIBRARY_PATH</code> environment variable before launching
your game to <a href="http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html#AEN80">instructs the dynamic loader to search the specified
directory for libraries</a>.</li>
</ul>


<p>This way, your game suddenly prefers the runtime versions of libraries
rather than your own. It&rsquo;s worth noting that if your game depends on a
library that is <strong>not</strong> present in the runtime, but the user has it
installed on their system, your game will run without error. This is
something to be wary of, since you don&rsquo;t know what version of the
library you&rsquo;re getting, and it&rsquo;ll fail to execute on some users'
systems.</p>

<p>The <a href="https://github.com/ValveSoftware/steam-runtime">runtime SDK</a> is just a set of tools that have been
told to look for libraries and headers inside the SDK rather than in the
system directories, so that the linker and compiler knows about the
right version of the libraries.</p>

<h2>Contents of the runtime</h2>

<p>Since the steam-runtime doesn&rsquo;t require Steam, let&rsquo;s take a look at what
the runtime contains, and see if there&rsquo;s a way to use this in our
non-Steam distributions.</p>

<p>You can find the runtime binaries hosted on the Steam CDN as a tar
archive:
<a href="http://media.steampowered.com/client/runtime/steam-runtime-release_latest.tar.xz">http://media.steampowered.com/client/runtime/steam-runtime-release_latest.tar.xz</a></p>

<p>I&rsquo;ve provided a script on GitHub that you can use to make sure you have
the latest runtime downloaded to the current directory. <a href="https://gist.github.com/jorgenpt/07f207aefdd49b61c7b6#file-update_runtime-sh">The helper
script is update_runtime.sh</a>.</p>

<p>The runtime tar archive contains some helper scripts, and the various
files needed for each library, as well as the libraries themselves. For
each library, there&rsquo;s a 32bit version (in the i386 directory) and a
64bit version (in the amd64 directory.)</p>

<p>Surprisingly enough, the runtime <em>also</em> contains (as of 2014-05-26) the
documentation needed for each library, which takes up almost half of the
space required by an extracted version of the runtime. To strip out the
documentation, and extract just the architecture you care about, I&rsquo;ve
written <a href="https://gist.github.com/jorgenpt/07f207aefdd49b61c7b6#file-extract_runtime-sh">another little helper script called
extract_runtime.sh</a>.</p>

<p>With this script, you&rsquo;ll be left with about ~100MB of libraries per
architecture. You can probably tailor the set of libraries for your
title to reduce the size even further, but that&rsquo;s left as an exercise
for the reader.</p>

<h2>Conclusion</h2>

<p>The Steam runtime is a useful collection of libraries that helps solve
the important problem of operating system fragmentation (different Linux
distributions, different versions). It has a lot of value outside of
Steam as well, and should be trivially re-usable for your non-Steam
distribution.</p>

<p>In my next blog post, I will cover the details of distributing a game
that relies on the steam-runtime to hermeticize its environment, outside
of Steam.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DT_RPATH (ld) & @rpath (dyld)]]></title>
    <link href="http://jorgen.tjer.no/post/2014/05/20/dt-rpath-ld-and-at-rpath-dyld/"/>
    <updated>2014-05-20T22:06:29-07:00</updated>
    <id>http://jorgen.tjer.no/post/2014/05/20/dt-rpath-ld-and-at-rpath-dyld</id>
    <content type="html"><![CDATA[<p>Mac and Linux have two similarly named concepts that both deal with
dynamic loading, that behave quite differently: <code>@rpath</code> (under Mac OS
X&rsquo;s dyld) and <code>DT_RPATH</code> (or just rpath, under Linux' ld.)</p>

<p>Having done development (and more importantly, deployment) on both of
these platforms, I&rsquo;ve experienced first-hand how those concepts can get
a little jumbled in your mind, so here&rsquo;s a brief overview.</p>

<!-- more -->


<h2>DT_RPATH</h2>

<p>DT_RPATH, or more commonly just rpath, is a property set on an ELF
file<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. It points to a list of directories that the dynamic linker
will consider when loading a shared library. DT_RPATH is set at
link-time with the <code>-rpath</code> option to <code>ld</code>.  If you invoke <code>ld</code> through
<code>gcc</code> (or another compiler, like <code>g++</code>), then you can use the <code>-Wl</code>
option to pass arguments through to <code>ld</code>. You use commas to separate
arguments passed to <code>-Wl</code>.</p>

<p>```
$ gcc program.c -lm -o program &lsquo;-Wl,-rpath,$ORIGIN/lib&rsquo;
$ ldd program | grep libm</p>

<pre><code>    libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f3b9ad94000)
</code></pre>

<p>$ mkdir lib &amp;&amp; cp /lib/x86_64-linux-gnu/libm.so.6
$ ldd program | grep libm</p>

<pre><code>    libm.so.6 =&gt; /home/jorgenpt/lib/libm.so.6 (0x00007f1440b0c000)
</code></pre>

<p>```</p>

<p>The snippet above also shows one of the three special variables<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> you
can include in an rpath, $ORIGIN. $ORIGIN gets replaced at runtime with
the directory in which our executable lives. DT_RPATH is transitive,
meaning it applies to any dependencies of our dependencies (unlike
DT_RUNPATH, but I won&rsquo;t talk about that here.) If our executable links
with libfoo, and libfoo depends on libbar, libfoo will include our rpath
in its search for libbar. (<strong>EDIT 2014-05-25</strong>: You might need
<code>-Wl,-z,origin</code> for GCC to allow $ORIGIN to be expanded.)</p>

<p>$ORIGIN is also commonly expanded by bash or zsh, so we use single
quotes around our <code>-Wl,-rpath,$ORIGIN/lib</code> option to prevent that from
happening. To make sure that $ORIGIN didn&rsquo;t get expanded, you can run
<code>readelf -d my_executable | grep -i rpath</code> to see the value of your
rpath, making sure it starts with <code>$ORIGIN</code>.</p>

<p>To specify multiple paths, separate them by a colon, like
<code>-Wl,-rpath,$ORIGIN/lib:$ORIGIN/lib/amd64</code>.</p>

<p>As you might be able to tell, rpath is great for creating self-contained
applications. You still have to be careful, as any libraries that are
missing from your rpath will still be (silently) searched for in the
system directories. I highly recommend asking users for <code>ldd</code> output if
you&rsquo;re trying to debug something with your dependencies.</p>

<p>Many people use LD_LIBRARY_PATH to achieve a similar effect.
LD_LIBRARY_PATH is not set at link-time, but rather as an environment
variable when your application is run. This is for example what <a href="https://github.com/ValveSoftware/steam-runtime">Valve&rsquo;s
steam-runtime</a> does to guarantee that your dynamically
linked libraries will be picked from the Steam runtime libraries rather
than the system libraries.</p>

<p>The benefit of using LD_LIBRARY_PATH is that it can be set for
applications you cannot edit, but the downside is that it also applies
to any applications launched by the application in question. Say that
you have an application that launches <code>dbus-send</code> or <code>aplay</code> &mdash; since
they&rsquo;re system applications, you&rsquo;d want them to pick their dependencies
from the system, not your LD_LIBRARY_PATH.</p>

<p>Interaction between LD_LIBRARY_PATH and your application&rsquo;s rpath is
well-defined: Your rpath is searched first, and anything it can&rsquo;t find
there it&rsquo;ll look for in LD_LIBRARY_PATH. Finally, if searches the
system directories<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>.</p>

<h2>@rpath</h2>

<p>While @rpath is named similarly to its Linux cousin, it behaves a bit
differently. When you dynamically link to a library on Mac OS X, the
linker stores the &ldquo;install name&rdquo; of the library inside your executable.
The install name is something that comes from the dylib you&rsquo;re linking
against, and by default it is the absolute path of the linked file. You
can change the install name by modifying the dylib after linking<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>.</p>

<p>After your application has been linked, you can change what the
application thinks the install name is for one of its dependent
libraries<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>.</p>

<p>Your application can set its own rpath at link-time using the same
<code>-Wl,-rpath,@executable_path</code> magic, but note that instead of $ORIGIN,
you use @executable_path or @loader_path. @executable_path behaves
like $ORIGIN, @loader_path is the directory of whatever object is doing the
loading, which could be a dylib that your application has loaded. For
details, <a href="https://wincent.com/wiki/@executable_path,_@load_path_and_@rpath">read this excellent article by Wincent Colaiuta</a> and
<a href="https://www.mikeash.com/pyblog/friday-qa-2009-11-06-linking-and-install-names.html">this blog post by Mike Ash</a>.</p>

<p>This rpath does <em>not</em> do anything by default. To make it take effect,
the install name for the shared library has to start with <code>@rpath/</code> &mdash;
and the dynamic linker will then substitute each of the possible values
for <code>@rpath</code> in order. This means that you&rsquo;ll typically change the
install name of the dylib (if it&rsquo;s a dylib you built yourself) or change
the install name inside the application.</p>

<p>Under Mac OS X, you have the DYLD_LIBRARY_PATH environment variable &mdash;
and this behaves just like it does on Linux. When DYLD_LIBRARY_PATH is
set, it is checked before the install name (and therefore, @rpath) is
consulted.</p>

<h2>Conclusion</h2>

<p>Hopefully this helps you understand some nuances of dynamic linking on
Mac OS X versus Linux. In my next blog post, I hope to show how you can
use DT_RPATH on Linux to link with the Steam runtime when distributing
your game outside of Steam.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>This also applies to .so&rsquo;s &ndash; when one of your dynamically loaded libraries load another dynamic library, their rpath is searched first (if any), then your main application&rsquo;s rpath is searched.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>The other two variables are <code>$LIB</code> and <code>$PLATFORM</code>, and they deal with finding architecture-specific binaries.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>The truth is a little more complicated, see the ld.so manpage for more info. (http://man7.org/linux/man-pages/man8/ld.so.8.html)<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>See the man page for install_name_tool (<code>install_name_tool -id @rpath/my.dylib my.dylib</code>)<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p>See the man page for install_name_tool (<code>install_name_tool -change old.dylib @rpath/new.dylib my_application</code>)<a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
