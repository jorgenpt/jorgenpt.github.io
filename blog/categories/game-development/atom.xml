<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: game development | Jørgen's Blog]]></title>
  <link href="https://jorgen.tjer.no/blog/categories/game-development/atom.xml" rel="self"/>
  <link href="https://jorgen.tjer.no/"/>
  <updated>2023-03-04T12:33:32-08:00</updated>
  <id>https://jorgen.tjer.no/</id>
  <author>
    <name><![CDATA[Jørgen Tjernø]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Unreal Engine and Continuous Integration]]></title>
    <link href="https://jorgen.tjer.no/post/2023/03/04/unreal-ci/"/>
    <updated>2023-03-04T11:25:52-08:00</updated>
    <id>https://jorgen.tjer.no/post/2023/03/04/unreal-ci</id>
    <content type="html"><![CDATA[<p>Unreal Engine and continuous integration presents some unique challenges (shared
by some other game engines as well) and most CI tools aren&rsquo;t a great fit for
those, so this post enumerates what those challenges are and what is
<strong>actually</strong> required of a CI tool for our use cases.</p>

<!-- more -->


<p>I am not a build engineer, but a well functioning continuous integration set-up
is an important part of a good developer user experience and required to build
high quality products. I tend to help with any part of the development process
that&rsquo;s valuable to the team, and so I often end up thinking about CI.</p>

<p>Since I&rsquo;ve been working with Unreal for about seven years, I figured I&rsquo;d outline
what outline what an Unreal workflow looks like andt hen rant a little bit about
what I don&rsquo;t have.</p>

<a name="A.common.Unreal.Engine.pipeline"></a>
<h2>A common Unreal Engine pipeline</h2>

<p>I&rsquo;ll use the term <strong>Host Platform</strong> to refer to the platform used for
development (or needed by a paired <strong>Target Platform</strong>), which will usually be
Windows and sometimes Linux or macOS.</p>

<p><strong>Target Platform</strong> refers to a platform the game runs on, which can be any
number of platforms like Windows, macOS, PS5, iOS, Android, etc. Some target
platforms require certain host platforms, like iOS requiring macOS or PS5
requiring Windows.</p>

<ul>
<li>Build each Host Platform editor

<ul>
<li><strong>Inputs</strong>: Source code</li>
<li><strong>Outputs</strong>: Editor binaries</li>
</ul>
</li>
<li>Publish Host Platform editor to team

<ul>
<li><strong>Inputs</strong>: Editor binaries</li>
<li><strong>Outputs</strong>: Binaries in Perforce (for UGS or just in-tree)</li>
</ul>
</li>
<li>Build binary for each Target Platform (this can include both clients and servers)

<ul>
<li><strong>Inputs</strong>: Source code</li>
<li><strong>Outputs</strong>: Game binaries</li>
</ul>
</li>
<li>Cook content for each Target Platform

<ul>
<li><strong>Inputs</strong>: Source content, editor binaries for paired Host Platform</li>
<li><strong>Outputs</strong>: Cooked content assets or PAK files</li>
</ul>
</li>
<li>Stage game for each Target Platform

<ul>
<li><strong>Inputs</strong>: Game binaries, cooked content</li>
<li><strong>Outputs</strong>: Staged game ready for publishing</li>
</ul>
</li>
<li>Publish game to storefronts

<ul>
<li><strong>Inputs</strong>: Staged game</li>
<li><strong>Outputs</strong>: Game on one or more storefront CDNs (Steam, EGS, etc)</li>
</ul>
</li>
</ul>


<p>Depending on your architecture, this might also have additional tools or
services building &amp; publishing in parallel (sometimes lockstep &ndash; e.g. we don&rsquo;t
publish new client binaries to the storefront unless the server binary
successfully published and the backend on-demand asset cook reported success).</p>

<a name="Unique.challenges.for.CI.in.games"></a>
<h2>Unique challenges for CI in games</h2>

<p>There are three things I consider to be somewhat unique to managing CI in games,
namely:</p>

<ol>
<li><strong>Artifact size</strong> &ndash; outputs from build steps range from hundreds of megabytes to
tens of gigabytes.</li>
<li><strong>Team visibility</strong> &ndash; the build process affects and is affected by a large
number of non-technical staff.</li>
<li><strong>Vaguely complicated dependency graphs</strong> &ndash; as you can see from the above, cooking only
requires editor binaries, but staging requires the output of cook and binaries.</li>
</ol>


<p><strong>Artifact size</strong> means that many common ways of pushing inputs &amp; outputs can
fall short, and you often require large backing stores &amp; good retention
policies. I&rsquo;ve only had bad experiences with Jenkins' artifact management, and
usually we just fall back on pushing things to S3 directly.</p>

<p><strong>Team visibility</strong> means that artists and designers can check in changes that
they both want to know when are available to e.g. playtests and that also
might cause the build to fail. We want these failures to be actionable by the
non-technical staff without needing to involve an engineer, and we want the
state of the build to be something they can inspect on their own.</p>

<p><strong>Vaguely complicated dependency graphs</strong> means that you ideally want to have
&ldquo;join points&rdquo; in your CI system, so that you can take the input from two
different jobs and combine them into a third job. In the past, we&rsquo;ve put
together hacks that rely on S3 markers to detect if the other job has finished,
but more commonly teams tend to either create large serial build pipelines
(build editor, then game binaries, then cook, then publish) or duplicate work
(e.g. build the paired host platform editor for each <strong>target</strong> platform so you
can cook without knowing when the host platform editor build is done).</p>

<a name="Shortcomings.of.existing.CI.tools"></a>
<h2>Shortcomings of existing CI tools</h2>

<p>First of all, most CI tools are not great at letting you filter the information
you expose to the end user. That means that there tends to be information
overload, both for engineers and more importantly, for non-engineers. I am
starting to come around on the notion that this is fine &ndash; we develop our own
tools to handle this. Things like badges in Unreal Game Sync and log-parsing
Slack bots that extract (more) actionable information.</p>

<p>Secondly, the way we would like to structure our dependency graphs to achieve
lower latency builds is as far as I&rsquo;ve seen not well supported in neither
Jenkins nor buildbot. Having to fight the CI system to achieve this means that
people tend to just .. not, and instead just throw more hardware at it.</p>

<p>Finally, especially Jenkins has this problem of wanting to solve too many of my
problems. There&rsquo;s a plugin for <strong>everything</strong>, but I rarely use a plugin without
finding that it has some shortcoming or doesn&rsquo;t fit my particular use case. When
that happens, it&rsquo;s usually quite painful &ndash; writing (or modifying) and deploying
plugins for Jenkins is a huge pain. At the end of the day, we usually write our
own tools, and I&rsquo;d much rather have a system that <strong>supports</strong> that, rather than
gets in the way of it.</p>

<a name="What.I.need.from.a.CI.tool"></a>
<h2>What I need from a CI tool</h2>

<p>In some ways, I think Jenkins and its ecosystem has too much complexity, and I&rsquo;d
love something a little leaner. With that in mind, I&rsquo;ve started to try to
distill what I actually want / need from a tool:</p>

<ol>
<li>Trigger a build when there&rsquo;s a Perforce change</li>
<li>Run a bunch of commands, some in parallel, some in serial, across a number of
nodes with different OSes (as an aside, I quite like GitHub Workflow&rsquo;s <a href="(https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#grouping-log-lines)">log
grouping</a> as a tool to let complex commands break up their
output for consumption)</li>
<li>Report failures in a way where I can automatically introspect and format it
(ideally some way of hooking into &ldquo;events&rdquo; from my build job, like failure)</li>
<li>Store secrets we can expose to jobs</li>
<li>Configuration of the build pipeline lives in SCM and doesn&rsquo;t require me to
re-deploy the CI itself (looking at you, buildbot)</li>
<li>Authentication (single sign-on with Google, specifically) with read-only or
read-write permissions</li>
<li>If we&rsquo;re being greedy, ability to spin up &amp; shut down EC2 instances for the
jobs to run on, or at least some way to hook into the host provisioning to do
this (we currently do this manually in our pipeline, because all the plugins
assume you have an AMI or a docker image, but I have like ..
already-provisioned nodes I want to use)</li>
</ol>


<p>I think that when it comes to a plugin / component architecture, I&rsquo;d much rather
have a simple structure where components can be included per-job, and are just
programs that run. Whether it&rsquo;s a shell script or a Rust program, it should be a
way to bundle &amp; configure tools that&rsquo;s no different than what I can do in my own
build definition, so that it&rsquo;s trivial to expand when you outgrow them or create
new ones from existing build definitions.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AIE presentation slides]]></title>
    <link href="https://jorgen.tjer.no/post/2019/01/10/aie-presentation/"/>
    <updated>2019-01-10T17:31:00-07:00</updated>
    <id>https://jorgen.tjer.no/post/2019/01/10/aie-presentation</id>
    <content type="html"><![CDATA[<p>I gave a brief presentation followed by a Q&amp;A for a class at the <a href="https://aie.edu/">Academy of
Interactive Entertainment</a> at their Seattle campus. It was
a part of their &ldquo;Lunchbox Speaker&rdquo; series where they host various speakers
from the game development industry.</p>

<p>It talks about some of the challenges we at <a href="https://www.undeadlabs.com">Undead Labs</a>
encountered developing State of Decay 2, and both practical steps we took to address it as
well as some of my opinions on how to avoid or address those things in the future.</p>

<p>Here are the slides from that talk:</p>

<ul>
<li><a href="/static/2019-01-09-aie.pdf">PDF slides</a></li>
<li><a href="/static/2019-01-09-aie-with-notes.pdf">PDF slides with speaker notes</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Experience America presentation slides]]></title>
    <link href="https://jorgen.tjer.no/post/2015/10/21/experience-america-presentation/"/>
    <updated>2015-10-21T09:30:00-07:00</updated>
    <id>https://jorgen.tjer.no/post/2015/10/21/experience-america-presentation</id>
    <content type="html"><![CDATA[<p>I gave a brief presentation followed by a Q&amp;A for a class of Danish high
school students who were in Seattle via the Experience America program.
As a part of that process, local game developers were invited to speak.</p>

<p>Here are the slides from that talk:</p>

<ul>
<li><a href="/static/2015-10-21-experience-america.pdf">PDF slides</a></li>
<li><a href="/static/2015-10-21-experience-america-with-notes.pdf">PDF slides with speaker notes</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[steam-runtime without Steam]]></title>
    <link href="https://jorgen.tjer.no/post/2014/05/28/steam-runtime-without-steam/"/>
    <updated>2014-05-28T08:28:28-07:00</updated>
    <id>https://jorgen.tjer.no/post/2014/05/28/steam-runtime-without-steam</id>
    <content type="html"><![CDATA[<p><strong>Updated 2014-06-03:</strong> Added information about <code>STEAM_RUNTIME</code> variable under <a href="/post/2014/05/28/steam-runtime-without-steam/#Runtime.dependencies.of.the.steam-runtime">the new embedded search path subsection</a>.</p>

<p><strong>Updated 2016-01-03:</strong> Fixed dead links to Valve&rsquo;s steam-runtime patches collection.</p>

<p>If you&rsquo;ve ever had customers report errors like these, then this post
might be for you:</p>

<ul>
<li><code>./foo: /usr/lib/x86_64-linux-gnu/libstdc++.so.6: version
`GLIBCXX_3.4.16` not found (required by ./foo)</code></li>
<li><code>./foo: error while loading shared libraries: libSDL2-2.0.so.0:
 cannot open shared object file: No such file or directory</code></li>
</ul>


<p>In my <a href="/post/2014/05/26/self-contained-game-distribution-on-linux/">previous post about self-contained distributions</a>,
we started looking at how the <a href="https://github.com/ValveSoftware/steam-runtime">steam-runtime project</a>
works. In this post, we&rsquo;ll make the steam-runtime work for us in a
self-contained distribution that you can ship without depending on
Steam.</p>

<p>I will present two possible ways of doing it:</p>

<ol>
<li>Using <a href="/post/2014/05/28/steam-runtime-without-steam/#Solution.1:.The.wrapper.script">a wrapper script</a>.</li>
<li>Using <a href="/post/2014/05/28/steam-runtime-without-steam/#Solution.2:.Embedded.search.path">an &ldquo;embedded search path&rdquo;</a>.</li>
</ol>


<p>If you&rsquo;re wondering why you would prefer the second approach, that
section starts with a rundown of the benefits inherent to it!</p>

<!-- more -->


<a name="Assumptions"></a>
<h2>Assumptions</h2>

<p>The remainder of this article makes a few assumptions, no matter which
of the two approaches you choose.</p>

<p>I assume that you&rsquo;ve extracted the steam-runtime into a directory named
<code>steam-runtime/</code> next to the executable. The easiest way to do this is
to use the two helper scripts I wrote, see the section on <a href="/post/2014/05/28/steam-runtime-without-steam/#Preparing.the.steam-runtime.for.repackaging">repackaging
the steam-runtime</a>. You should include the steam-runtime
directory when distributing <em>outside of</em> Steam, and distribute the exact
same package <strong>except</strong> for the steam-runtime directory when
distributing <em>through</em> Steam.</p>

<p>Excluding the steam-runtime can be done trivially inside your Steam
depot build script. Assuming you&rsquo;re building a depot from <code>build/linux</code>
(relative to your ContentRoot) with the binary living directly in that
directory, your script would contain something like this:</p>

<pre><code>"DepotBuildConfig"
{
    "DepotID" "1001"

    "FileMapping"
    {
        "LocalPath" "build\linux\*"
        "DepotPath" "."
        "recursive" "1"
    }

    "FileExclusion" "build\linux\steam-runtime"
}
</code></pre>

<p>It&rsquo;s worth noting that the FileExclusion is matched against your local
paths, not your depot paths, and it is implicitly recursive (the latter
doesn&rsquo;t seem to be documented <a href="https://partner.steamgames.com/documentation/steampipe">in the SteamPipe docs</a> as
of 2014-05-28.)</p>

<p>I assume you&rsquo;re already building your game with <a href="https://github.com/ValveSoftware/steam-runtime">the steam-runtime
SDK</a>. This is how you make sure your game is depending on
the right version of the libraries.</p>

<p>Finally, for simplicity sake I&rsquo;m also assuming you don&rsquo;t mind ~100MB of
additional data in your package, which is the size of the entire
steam-runtime for one architecture. If this is too much for you, you can
always manually strip out any unneeded libraries from the runtime.</p>

<a name="Preparing.the.steam-runtime.for.repackaging"></a>
<h3>Preparing the steam-runtime for repackaging</h3>

<p>I&rsquo;ve created <a href="https://github.com/jorgenpt/steam-runtime-helpers">two helper scripts</a>, one to make sure
you&rsquo;ve <a href="https://github.com/jorgenpt/steam-runtime-helpers/blob/master/update_runtime.sh">downloaded the latest runtime</a>, and one to <a href="https://github.com/jorgenpt/steam-runtime-helpers/blob/master/extract_runtime.sh">extract
the parts of the runtime you care about</a> (to reduce runtime
size from 400MB to 100MB, by excluding documentation and whatever
architecture you&rsquo;re <strong>not</strong> using.)</p>

<p>You would invoke them like this to download the latest runtime and
extract the 64bit libraries from it into the <code>build/linux/steam-runtime</code>
directory.</p>

<pre><code>./update_runtime.sh
./extract_runtime.sh steam-runtime-release_latest.tar.xz amd64 build/linux/steam-runtime
</code></pre>

<a name="Solution.1:.The.wrapper.script"></a>
<h2>Solution 1: The wrapper script</h2>

<p>The least invasive way to accomplish what we want is to basically do
what Steam does: Set up the runtime environment variables via
<code>LD_LIBRARY_PATH</code>, and launch the main binary.</p>

<p>To make it even easier, I&rsquo;ve put together <a href="https://github.com/jorgenpt/steam-runtime-helpers/blob/master/launch_wrapper.sh">a little wrapper
script</a> that does exactly that. Name the script <code>foo.sh</code>
or <code>foo</code>, and put it in the same directory as your executable, which it
will then assume is named <code>foo.bin</code>.</p>

<p>The script should gracefully handle being launched from Steam, as it&rsquo;ll
detect that the runtime has already been set up.</p>

<a name="Solution.2:.Embedded.search.path"></a>
<h2>Solution 2: Embedded search path</h2>

<p>First off, why would you prefer this approach to using a wrapper script?</p>

<ul>
<li>Shell scripts are fragile &ndash; it&rsquo;s easy to get something wrong, like
incorrectly handling spaces in filenames, or something equally silly.</li>
<li>A shell script gives you another file that you have to be careful to
maintain the executable bit on.</li>
<li>Shell scripts are text files, and your VCS / publishing process might
mangle the line endings, which makes everyone sad (<code>bad interpreter:
/bin/bash^M: no such file or directory</code>)</li>
<li>A customer could accidentally launch the wrong thing (i.e. the
<code>.bin</code>-file rather than the script), which might work on some
machines, fail in subtle ways on other machines, and not work at all
on the rest of them.</li>
<li>Launching the game in a debugger requires more complexity in your
script, like the <code>--gdb</code> logic in
<a href="https://github.com/jorgenpt/steam-runtime-helpers/blob/master/launch_wrapper.sh">launcher_wrapper.sh</a>, to make the game, but not the
debugger, pick up the runtime libraries.</li>
<li>If you launch any system binaries from outside of the runtime without
taking care to unset <code>LD_LIBRARY_PATH</code>, they will implicitly be using
the runtime libraries, which might not cause problems.</li>
</ul>


<p>The alternative to the wrapper script is using <code>DT_RPATH</code>, which I&rsquo;ve
talked about in <a href="/post/2014/05/20/dt-rpath-ld-and-at-rpath-dyld/">a previous blog post</a>. This approach is a
little more invasive to your build process, but overall it should
require less code.</p>

<p>Simply invoke your linker with the <code>-rpath</code> option pointing to various
subdirectories of the steam-runtime directory. For GCC and Clang, you
would add <code>-Wl,-rpath,&lt;path1&gt;:&lt;path2&gt;:...</code> to the linking step to
accomplish this.</p>

<p>These are the paths to the 64bit libraries in the steam-runtime:</p>

<ul>
<li>amd64/lib/x86_64-linux-gnu</li>
<li>amd64/lib</li>
<li>amd64/usr/lib/x86_64-linux-gnu</li>
<li>amd64/usr/lib</li>
</ul>


<p>These are the paths to the 32bit libraries:</p>

<ul>
<li>i386/lib/i386-linux-gnu</li>
<li>i386/lib</li>
<li>i386/usr/lib/i386-linux-gnu</li>
<li>i386/usr/lib</li>
</ul>


<p>Assuming you&rsquo;re using GCC and the steam-runtime lives next to the
executable, you&rsquo;d use these GCC options for a 64bit binary:</p>

<pre><code>-Wl,-z,origin -Wl,-rpath,$ORIGIN/steam-runtime/amd64/lib/x86_64-linux-gnu:$ORIGIN/steam-runtime/amd64/lib:$ORIGIN/steam-runtime/amd64/usr/lib/x86_64-linux-gnu:$ORIGIN/steam-runtime/amd64/usr/lib
</code></pre>

<p>And you would use these option for a 32bit binary:</p>

<pre><code>-Wl,-z,origin -Wl,-rpath,$ORIGIN/steam-runtime/i386/lib/i386-linux-gnu:$ORIGIN/steam-runtime/i386/lib:$ORIGIN/steam-runtime/i386/usr/lib/i386-linux-gnu:$ORIGIN/steam-runtime/i386/usr/lib
</code></pre>

<a name="Runtime.dependencies.of.the.steam-runtime"></a>
<h3>Runtime dependencies of the steam-runtime</h3>

<p>In addition to redirecting the ELF loader to the steam-runtime, there are some runtime dependencies within those dynamic libraries that need to be redirected as well. Luckily, Valve has done this work for us, and <a href="https://github.com/ValveSoftware/steam-runtime/tree/1a9c7173fc2092a7214eacdd0ffcbff3c5afe1e5/patches">patched these libraries to look elsewhere</a>. In order to know what the &ldquo;base&rdquo; of the runtime is, it looks at the <code>STEAM_RUNTIME</code> environment variable.</p>

<p>The first version of this post didn&rsquo;t include this detail, and you might&rsquo;ve run into errors like these:</p>

<pre><code>symbol lookup error: /usr/lib/x86_64-linux-gnu/gio/modules/libdconfsettings.so: undefined symbol: g_mapped_file_get_bytes
</code></pre>

<p>This is because glib has a <a href="https://github.com/ValveSoftware/steam-runtime/blob/1a9c7173fc2092a7214eacdd0ffcbff3c5afe1e5/patches/glib2.0/01_steam_runtime_path.patch#L16">runtime search for plugins</a> that directly calls <code>dlopen()</code> on an absolute path.</p>

<p>The solution to this problem is to have the first thing in your <code>main()</code> method on Linux be:</p>

<pre><code class="c">if (!getenv("STEAM_RUNTIME")) {
    setenv("STEAM_RUNTIME", figureOutSteamRuntimePath(), 1);
}
</code></pre>

<p>A full sample for your <code>main()</code> is <a href="https://github.com/jorgenpt/steam-runtime-helpers/blob/master/sample_embedded_path_main.c">available in the helpers GitHub repository</a>.</p>

<a name="Conclusion"></a>
<h2>Conclusion</h2>

<p>With just a small modification to your build system and a ~100MB larger
distribution, you can make your executables run across a wide variety of
Linux distributions and user setups. I highly recommend the embedded
search path solution, which is what I used for <a href="http://www.uberent.com/pa/">Planetary
Annihilation</a>&rsquo;s Linux release.</p>

<p>When shipping your own steam-runtime, you are responsible for updating
the runtime. The date of the latest update can be found inside the
<a href="http://media.steampowered.com/client/runtime/steam-runtime-release_latest.tar.xz.md5">runtime MD5 file</a>. In addition, you are responsible for
respecting the licenses of all the packages included in the runtime &ndash;
including any clauses regarding redistribution.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Self-contained game distribution on Linux]]></title>
    <link href="https://jorgen.tjer.no/post/2014/05/26/self-contained-game-distribution-on-linux/"/>
    <updated>2014-05-26T21:10:28-07:00</updated>
    <id>https://jorgen.tjer.no/post/2014/05/26/self-contained-game-distribution-on-linux</id>
    <content type="html"><![CDATA[<p>Distributing a game on Linux can be a little intimidating, and there are
definitely pitfalls. The main problem is making sure your game runs on
all of your users' machines, and outside of hardware and drivers, the
root of the problem is usually one of two things:</p>

<ol>
<li>You make an assumption about what libraries are present on the system.</li>
<li>You make an assumption about what version of a library is present on the system.</li>
</ol>


<p>This is very easy to accidentally do, as adding <code>-lSDL2</code> to the linker&rsquo;s
command line might work perfectly fine on your machine, but you forgot
that you installed SDL2 by hand 4 months ago. Another cause could be
that while <strong>your</strong> Linux distribution came with SDL2 preinstalled,
another distribution (that your users use) might not. Finally, maybe
your distribution came with v2 of some library, but your users only have
v1.</p>

<p>The best way to avoid this is to make your game distribution &ldquo;hermetic,&rdquo;
meaning that it contains all of its own dependencies. There are two main
ways to achieve this:</p>

<ol>
<li>Statically linking with all of your dependencies.</li>
<li>Dynamically linking with all of your dependencies, and pointing the
system&rsquo;s runtime loader at a copy of the libraries you bundle with
your game.</li>
</ol>


<p>Statically linking comes with its own set of problems, so this post
talks about solving the problem with dynamic linking.</p>

<a name="Introducing.the.steam-runtime"></a>
<h2>Introducing the steam-runtime</h2>

<p>It turns out that Valve has already solved this problem in Steam with
<a href="https://github.com/ValveSoftware/steam-runtime">something called the steam-runtime</a>. Contrary to what
its name indicates, it has <strong>no direct dependency on Steam nor does it
even assume that it is installed</strong>. It is merely a controlled set of
open source libraries (with some patches) and associated tools to use
those libraries - to make your game build hermetic.</p>

<!-- more -->


<p>If your game is running under Steam, you don&rsquo;t need to do much. Build
your game with the steam-runtime SDK, make sure all of your dependencies
exist inside of the runtime, and ship the game binaries to Steam. On the
receiving end, Steam will make sure that your users have the latest
version of the steam-runtime, and execute your game inside of it.</p>

<p>If you, like many others, also distribute your game outside of Steam,
you&rsquo;ll need to find another solution. The obvious solution is to build
on their work - it&rsquo;s an open source project that solves the problem
perfectly!</p>

<p>(<strong>Update:</strong> If you want to cut directly to the proposed solution, read
my <a href="/post/2014/05/28/steam-runtime-without-steam/">follow-up post on the details of using the steam-runtime without
depending on Steam</a>.)</p>

<a name="Workings.of.the.steam-runtime"></a>
<h2>Workings of the steam-runtime</h2>

<p>When I say that your game is executed &ldquo;inside&rdquo; of the runtime when
launched through Steam, I specifically mean that:</p>

<ul>
<li>The steam-runtime being present in some location Steam knows about</li>
<li>Steam sets the <code>LD_LIBRARY_PATH</code> environment variable before launching
your game to <a href="http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html#AEN80">instruct the dynamic loader to search the specified
directory for libraries</a>.</li>
</ul>


<p>This way, your game suddenly prefers the runtime versions of libraries
rather than your own. It&rsquo;s worth noting that if your game depends on a
library that is <strong>not</strong> present in the runtime, but the user has it
installed on their system, your game will run without error. This is
something to be wary of, since you don&rsquo;t know what version of the
library you&rsquo;re getting, and it&rsquo;ll fail to execute on some users'
systems.</p>

<p>The <a href="https://github.com/ValveSoftware/steam-runtime">runtime SDK</a> is just a set of tools that have been
told to look for libraries and headers inside the SDK rather than in the
system directories, so that the linker and compiler knows about the
right version of the libraries.</p>

<a name="Contents.of.the.runtime"></a>
<h2>Contents of the runtime</h2>

<p>Since the steam-runtime doesn&rsquo;t require Steam, let&rsquo;s take a look at what
the runtime contains, and see if there&rsquo;s a way to use this in our
non-Steam distributions.</p>

<p>You can find the runtime binaries hosted on the Steam CDN as a tar
archive:
<a href="http://media.steampowered.com/client/runtime/steam-runtime-release_latest.tar.xz">http://media.steampowered.com/client/runtime/steam-runtime-release_latest.tar.xz</a></p>

<p>I&rsquo;ve provided a script on GitHub that you can use to make sure you have
the latest runtime downloaded to the current directory. <a href="https://github.com/jorgenpt/steam-runtime-helpers/blob/master/update_runtime.sh">The helper
script is update_runtime.sh</a>.</p>

<p>The runtime tar archive contains some helper scripts, and the various
files needed for each library, as well as the libraries themselves. For
each library, there&rsquo;s a 32bit version (in the i386 directory) and a
64bit version (in the amd64 directory.)</p>

<p>Surprisingly enough, the runtime <em>also</em> contains (as of 2014-05-26) the
documentation needed for each library, which takes up almost half of the
space required by an extracted version of the runtime. To strip out the
documentation, and extract just the architecture you care about, I&rsquo;ve
written <a href="https://github.com/jorgenpt/steam-runtime-helpers/blob/master/extract_runtime.sh">another little helper script called
extract_runtime.sh</a>.</p>

<p>With this script, you&rsquo;ll be left with about ~100MB of libraries per
architecture. You can probably tailor the set of libraries for your
title to reduce the size even further, but that&rsquo;s left as an exercise
for the reader.</p>

<a name="Conclusion"></a>
<h2>Conclusion</h2>

<p>The Steam runtime is a useful collection of libraries that helps solve
the important problem of operating system fragmentation (different Linux
distributions, different versions). It has a lot of value outside of
Steam as well, and should be trivially re-usable for your non-Steam
distribution.</p>

<p><strong>Update</strong>: In the follow-up post, I cover <a href="/post/2014/05/28/steam-runtime-without-steam/">the details of distributing
a game that relies on the steam-runtime to hermetically seal its
environment, without depending on Steam</a>.</p>
]]></content>
  </entry>
  
</feed>
